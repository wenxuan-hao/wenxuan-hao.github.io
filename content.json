{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"网络/ip","slug":"网络-ip","date":"2019-12-22T14:30:26.000Z","updated":"2019-12-22T14:31:22.202Z","comments":true,"path":"2019/12/22/网络-ip/","link":"","permalink":"http://yoursite.com/2019/12/22/网络-ip/","excerpt":"","text":"AsyncProducer异步发送消息, 消息发送后立即返回; 如需获得消息发送成功的确认, 需将Config.Producer.Return.Successes设置为true(默认关闭), 调用Successes()方法, 从chanel中读取确认消息.此外, 错误返回的通道默认打开, 需要在新的goroutin中调用Errors()并做相应处理. 如不想获得错误消息, 可将Config.Producer.Return.Errors设置为false; 若消息发送失败, 会进行重试(默认三次), 重试三次后依然发送失败, 返回错误到error channel. APIfunc (asp *AsyncProducer) Close() (err error) //默认打开, 消息发送失败的返回信息 func (asp *AsyncProducer) Errors() &lt;-chan *ProducerError func (asp *AsyncProducer) Send() chan&lt;- *ProducerMessage //消息发送成功后, 返回确认信息; 需将Producer.Return.Successes设置为true; 包含该条message发送到的topic, partition, offset等信息; func (asp *AsyncProducer) Successes() &lt;-chan *ProducerMessageSyncProducer同步发送消息; 发送失败返回错误; NewManualRetrySyncProducer()创建手动控制重发机制的SyncProducer; NewSyncProducer()采用默认重发机制; APIfunc (sp *SyncProducer) Close() (err error) func (sp *SyncProducer) SendMessage(msg *ProducerMessage) (topic string, partition int32, offset int64, err error) func (sp *SyncProducer) SendMessages(msgs []*ProducerMessage) errorConfig 配置 说明 默认值 Producer.Return.Successes 是否打开发送成功的消息确认; 如果设置为true, 则必须从success chanel中读取 false Producer.Return.Errors 是否打开消息发送失败的通知; 如果设置为ture, 则必须从errors chanel中读取 true Producer.Retry.Max 发送失败重试的最大次数, 若全部发送失败, 就会发送错误通知到errors chanel 3 Producer.Retry.BackOff 尝试重试指定topic分区的失败请求之前等待的时间。这样可以避免在某些故障情况下高频次的重复发送请求。 100ms Producer.MaxMessageBytes 消息大小的最大值 1000000 Producer.RequiredAcks 生产者需要leader确认请求完成之前接收的应答数。若为0, 生产者将不等待任何消息确认, 无法获知消息是否被服务器接收, 且重试机制不生效; 若为1, leader写入消息到本地日志就立即响应，而不等待所有follower应答。在这种情况下，如果响应消息之后但follower还未复制之前leader立即故障，那么消息将会丢失。若为-1,这意味着leader将等待所有副本同步后应答消息, 这是最强壮的可用性保障。 1 Producer.Timeout 控制客户端等待请求响应的最长时间。如果在超时之前未收到响应，客户端将在必要时重新发送请求，如果重试耗尽，则该请求将失败。注: 不支持nanoseconds级别的设置 10m Producer.MaxRequestSize socket请求的最大字节数, 若超出该值返回PacketEncodingError 100 * 1024 * 1024 Producer.MaxMessages socket请求的最大消息数 0 Producer.Frequency socket请求的频率的最佳尝试 CosumerConsumer有两种消费模式, NewSimpleConsumer()会将所有分区的消息返回到同一个message chanel中, 调用Message()进行读取; NewHighLevelConsumer()则需单独消费每个Partition的数据, 调用Partition()方法, 返回每个Partition对应的PartitionConsumer, 再进行消费; APIfunc (this *Consumer) Close() error //提交本地mark的offset; 出于性能方面的考虑, 不必每消费一条消息都进行提交; 可通过设置Consumer.Offsets.CommitInterval设置自动提交的时间间隔 func (this *Consumer) Commit() error func (this *Consumer) Errors() &lt;-chan error func (this *Consumer) MarkOffset(msg *ConsumerMessage, metadata string) func (this *Consumer) Messages() &lt;-chan *ConsumerMessage func (this *Consumer) Partition() &lt;-chan ClusterPartitionConsumer func (this *Consumer) ResetOffset(msg *ConsumerMessage, metadata string) //得到该consumer消费的topic以及每个topic对应的partition func (this *Consumer) Subscriptions() map[string][]int32Config 配置 说明 默认 Consumer.Return.Error 如果设置为true, 所有与消费有关的错误都会返回到error chanel true Group.Return.Notifications 如果设置为true, 当client的分区发生变化时, 就会想notification chanel发送通知, 调用者必须读取, 并进行自己本地的处理 false Group.Offsets.Retry.Max 提交offset的最大次数 3 Group.Session.Timeout - 30s Group.Heartbeat.Interval - 3s Consumer.Retry.Backoff 读取消息失败后, 重试读取间隔的时间 2s Consumer.Fetch.Min 一次请求中, 从broker获取消息的最小字节数 1 Consumer.Fetch.Default 一次请求中, 从broker获取消息的默认大小 1MB Consumer.Fetch.Max 一次请求中, 从broker中获取消息的最大字节数; 若消息大于该值, 会返回ErrMessageTooLarge错误, 且消息不可消费 0(无限制) Cosumer.MaxWaitTime 等待消息大小大于等于Consumer.Fetch.Min的最大等待时间; 建议: 100-500ms适用于大多数情况 250ms Consumer.MaxProcessingTime Consumer.Offsets.CommitInterval 自动提交offset的时间间隔 1s Consumer.Offsets.Initial 若无该group的offset的提交记录, 使用的初始offset; 可以指定为OffsetNewest或OffsetOldest; OffsetNewest","categories":[],"tags":[]},{"title":"MYBOLG","slug":"MYBOLG","date":"2019-09-22T18:30:32.000Z","updated":"2019-09-22T18:30:32.051Z","comments":true,"path":"2019/09/23/MYBOLG/","link":"","permalink":"http://yoursite.com/2019/09/23/MYBOLG/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-09-22T17:42:41.610Z","updated":"2019-09-22T17:42:41.610Z","comments":true,"path":"2019/09/23/hello-world/","link":"","permalink":"http://yoursite.com/2019/09/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}